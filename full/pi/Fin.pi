-- pi-forall library for finite numbers
-- The type 'Fin n' includes numbers drawn 
-- from the range 0 ... n - 1.
--
-- Some of these are adapted from Fin.agda

module Fin where

import Nat
import Equality
import Logic

-- Numbers bound within a finite range.  e.g. the type "Fin 3" has 
-- exactly three members:  
--    Zero [2]
--    Succ [2] (Zero [1])
--  and 
--    Succ [2] (Succ [1] (Zero [0]))
-- 

data Fin (n : Nat) : Type where
  Zero of [m:Nat][n = Succ m] 
  Succ of [m:Nat][n = Succ m] (Fin m)


x0 : Fin 3
x0 = Zero [2]

x1 : Fin 3
x1 = Succ [2] (Zero [1])

x2 : Fin 3
x2 = Succ [2] (Succ [1] (Zero [0]))

toNat : [n : Nat] -> Fin n -> Nat
toNat = \ [n] fn . 
  case fn of 
   Zero [m]   -> 0
   Succ [m] i -> plus 1 (toNat [m] i)

raise : [m : Nat] -> (n: Nat) -> Fin m -> Fin (plus n m)
raise = \ [m] n i. 
    case n of 
      Zero    -> i
      Succ n0 -> Succ [plus n0 m] (raise [m] n0 i) 

inject_1 : [m : Nat] -> Fin m -> Fin (Succ m)
inject_1 = \[m] f . Succ [m] f

inject : [m:Nat] -> (n:Nat) -> Fin m -> Fin (plus m n)
inject = \ [m] n fn. 
  case fn of 
    Zero [m0]   -> Zero [plus m0 n]
    Succ [m0] i -> Succ [plus m0 n] (inject [m0] n i) 

fpred : [n : Nat] -> Fin n -> Fin n
fpred = \ [n] fn . 
  case fn of 
    Zero [m]-> Zero [m]
    (Succ [m] i) -> inject_1 [m] i

zero_neq_succ : [n : Nat] -> [i : Fin n] -> neg ((Zero [n] : Fin (Succ n)) = Succ [n] i)
zero_neq_succ = \ [n] [i] p . contra p
   
succ_injective : [n : Nat] -> [i : Fin n] -> [j : Fin n] -> (Succ [n] i : Fin (Succ n)) = Succ [n] j -> i = j
succ_injective = \[n][i][j] p . 
   subst Refl by p

-- heterogeneous equality

fin_heq : [n: Nat] -> [m:Nat] -> (Fin n) -> (Fin m) -> Bool
fin_heq = \ [n] [m] fn1 fn2 . 
    case fn1 of 
      Zero [m1] ->  
         case fn2 of
            Zero [m2]      -> True
            Succ [m2] x    -> False
      Succ [m1] fn1' ->  
         case fn2 of
            Succ [m2] fn2' ->  fin_heq [m1][m2] fn1' fn2'
            Zero [m2] -> False
   

-- homogeneous equality

fin_eq : [n: Nat] -> (Fin n) -> (Fin n) -> Bool
fin_eq =  \ [n] fn1 fn2 .
   case fn1 of 
      Zero [m1] ->  
         case fn2 of
            Zero [m2]      -> True
            Succ [m2] x    -> False
      Succ [m1] fn1' ->  
         case fn2 of
            Succ [m2] fn2' ->  fin_eq [m1] fn1' fn2'
            Zero [m2] -> False

