module Lec4 where

-- Examples of "dirt-simple" datatypes 
-- booleans are primitive to the implementation (so that we can continue
-- to use if), but Void and Nat must be defined

not : Bool -> Bool
not = \ b . 
  case b of 
       True -> False
       False -> True


data Void : Type where {}   -- no constructors

false_elim : [A:Type] -> Void -> A @ 1
false_elim = \ [A] v . case v of {}

data Nat : Type where
  Zero
  Succ of (Nat)

is_zero : Nat -> Bool
is_zero = \ x . case x of 
   Zero -> True
   Succ n -> False

plus : Nat -> Nat -> Nat
plus = \ x y. case x of 
   Zero -> y
   Succ x' -> Succ (plus x' y)

-- Dependently-typed data constructor arguments

data SillyBool : Type where      
  ImTrue  of (b : Bool) (_ : b = True)
  ImFalse of (b: Bool)  (_ : b = False)

--
-- Another example, Days of the week.

data Day : Type where
   Monday
   Tuesday
   Wednesday
   Thursday 
   Friday
   Saturday
   Sunday
  
-- using datatypes

next_weekday : Day -> Day
next_weekday = \d . case d of 
   Monday -> Tuesday 
   Tuesday -> Wednesday
   Wednesday -> Thursday
   Thursday -> Friday
   Friday -> Monday
   Saturday -> Monday
   Sunday -> Monday

neg : Type -> Type
neg = \ x . (x -> Void)

next_is_not_saturday : (d: Day) -> neg (next_weekday d = Saturday) @ 1
next_is_not_saturday = \ d. 
  \pf. case d of
     Monday -> contra pf
     Tuesday -> contra pf
     Wednesday -> contra pf
     Thursday -> contra pf
     Friday -> contra pf
     Saturday -> contra pf
     Sunday -> contra pf


-- parameterized datatypes

data Maybe (A : Type) : Type where
   Nothing 
   Just of (A)

data Sigma (A: Type) (B : A -> Type) : Type where
    Prod of (x:A) (B x)


-- indexed datatypes

data Beautiful (n : Nat) : Type where
   B0 of [n = 0]
   B3 of [n = 3]
   B5 of [n = 5]
   Bsum of (m1:Nat)(m2:Nat)(Beautiful m1)(Beautiful m2)[n = plus m1 m2]

threeIsBeautiful : Beautiful 3
threeIsBeautiful = B3

eightIsBeautiful : Beautiful 8
eightIsBeautiful = Bsum 3 5 B3 B5

beautifulPlusEight : (n:Nat) -> Beautiful n -> Beautiful (plus 8 n) @ 1
beautifulPlusEight = \ n bn. Bsum 8 n eightIsBeautiful bn

data Gorgeous (n : Nat) : Type where
   G0 of [n = 0]
   Gplus3 of (m : Nat) (Gorgeous m) [n = plus 3 m]
   Gplus5 of (m : Nat) (Gorgeous m) [n = plus 5 m]

gorgeousPlus13 : (n : Nat) -> Gorgeous n -> Gorgeous (plus 13 n) @ 1
gorgeousPlus13 = \n gn. 
   Gplus5 (plus 5 (plus 3 n)) (Gplus5 (plus 3 n) (Gplus3 n gn)) 

gorgeousBeautiful : (n : Nat) -> Gorgeous n -> Beautiful n @ 1
gorgeousBeautiful = \n gn . case gn of 
   G0 -> B0
   Gplus3 m gm -> Bsum 3 m B3 (gorgeousBeautiful m gm)
   Gplus5 m gm -> Bsum 5 m B5 (gorgeousBeautiful m gm)



-----------------------------------------------------
-- The trade off for Sigma types in the context of irrelevance. 
-- If the first argument is irrelevant, we only have weak elimination
-- available.

-- Existential type
data Exists (B: Type -> Type) : Type where
  Pack of [x:Type] (B x)

counter : (Nat -> Nat) * (Nat -> Nat) * (Nat -> Nat)
counter = (\x . 0, ( \x. Succ x , \x . x))

-- This doesn't work
{-
ty : [B: Type -> Type] -> Exists B -> Type 
ty = \ [B]  x . case x of 
  Pack [x] y -> x

open : [B:Type -> Type] -> (x : Exists B) -> B (case x of Pack [x] y -> x)
open = \ [B]  x . case x of 
  Pack [z] y -> y
-}

-----------------------------------------------------------
-- Example of an abstract type with an irrelevant first component
-- must use case to destruct

Abs : Type
Abs = Exists (\t. (Nat -> t) * (t -> t) * (t -> Nat))

abs : Abs
abs = Pack [Nat] counter

example : Abs -> Nat
example = \ a . 
  case a of 
    Pack [t] tuple -> 
      let (constr, rest) = tuple in 
      let (incr, toNat) = rest in 
      toNat (incr (constr 0))

-----------------------------------------------
-- Example of an abstract type with an "relevant" first component
-- can define strong elimnators 


Abs2 : Type @ 1
Abs2 = { t : Type | (Nat -> t) * (t -> t) * (t -> Nat) }

abs2 : Abs2
abs2 = ( Nat , counter )

ty : Abs2 -> Type @ 1
ty = \a. let (x,y) = a in x

constr : (a : Abs2) -> Nat -> (ty a) @ 2
constr = \a. let (x,y) = a in 
  let (c, rest) = y in 
  c

incr : (a : Abs2) -> ty a -> ty a  @ 2
incr = \a. let (x,y) = a in 
  let (c, r) = y in 
  let (i, t) = r in 
  i

toNat : (a : Abs2) -> ty a -> Nat  @ 2
toNat = \a. let (x,y) = a in 
  let (c, r) = y in 
  let (i, t) = r in 
  t

example2 : Abs2 -> Nat
example2 = \ a .   
  toNat a (incr a (constr a 0))

-- This doesn't type check. The type system prevents us from 
-- confusing two different abstract types
-- 
--example3 : Abs2 -> Abs2 -> Nat
--example3 = \ a b .   
--  toNat a (incr b (constr a 0))
