module Logic where

-- Propositional Connectives

data Void : Type where {}   -- no constructors

false_elim : [A:Type] -> Void -> A
false_elim = \ [A] v . case v of {}

neg : Type -> Type
neg = \ x . (x -> Void)

-- products (conjunctions)

data And (A : Type) (B : Type) : Type where
  Conj of (_ : A) (_ : B)

proj1 : [A:Type] -> [B : Type] -> And A B -> A 
proj1 = \ [A] [B] p . case p of
  Conj x y -> x

proj2 : [A:Type] -> [B : Type] -> And A B -> B
proj2 = \ [A] [B] p . case p of
  Conj x y -> y

and_comm : [A : Type] -> [B : Type] -> And A B -> And B A
and_comm = \ [A][B] ab . case ab of 
                 (Conj x y) -> Conj y x

and_assoc : [A : Type] -> [B : Type] -> [C : Type] -> And A (And B C) -> And (And A B) C
and_assoc = \[A][B][C] abc . 
   case abc of 
     Conj a bc -> case bc of 
                   Conj b c -> Conj (Conj a b) c

-- sums (or)

data Either (A : Type) (B : Type) : Type where
  Inl of (A)
  Inr of (B)

or_comm : [A : Type] -> [B : Type] -> Either A B -> Either B A
or_comm = \ [A][B] ab . case ab of 
                 Inl a -> Inr a 
                 Inr b -> Inl b

or_assoc : [A : Type] -> [B : Type] -> [C : Type] -> Either A (Either B C) -> Either (Either A B) C
or_assoc = \[A][B][C] abc . case abc of 
     Inl a -> Inl (Inl a)
     Inr bc -> case bc of 
        Inl b -> Inl (Inr b)
        Inr c -> Inr c

-- if and only if

iff : (A : Type) -> (B : Type) -> Type 
iff = \ A B . And (A -> B) (B -> A)

iff_refl : [A : Type] -> iff A A
iff_refl = \[A]. Conj (\x . x) (\x . x)

iff_trans : [A : Type] -> [B : Type] -> [C : Type] -> (iff A B) -> (iff B C) -> (iff A C)
iff_trans = \ [A] [B] [C] iff1 iff2 . 
  case iff1 of 
    Conj ab ba -> 
      case iff2 of 
         Conj bc cb -> 
            Conj (\x. bc (ab x)) (\x. (ba (cb x)))

iff_sym : [A : Type] -> [B : Type] -> iff A B -> iff B A
iff_sym = \ [A][B] iff. 
  case iff of 
     Conj ab ba -> Conj ba ab

neg_false : [A : Type] -> iff (neg A) (iff A Void)
neg_false = \ [A] . Conj (\ x . Conj x (\y. false_elim [A] y)) (proj1 [A -> Void][Void -> A])
                                  

